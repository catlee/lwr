<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.8.1: http://docutils.sourceforge.net/" />
<title>Large Wooden Rabbit Architecture</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7056 2011-06-17 10:50:48Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="large-wooden-rabbit-architecture">
<h1 class="title">Large Wooden Rabbit Architecture</h1>

<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id3">Overview</a><ul>
<li><a class="reference internal" href="#goals" id="id4">Goals</a></li>
<li><a class="reference internal" href="#use-cases" id="id5">Use cases</a></li>
<li><a class="reference internal" href="#anti-goals" id="id6">Anti-Goals</a></li>
<li><a class="reference internal" href="#why-not-x" id="id7">Why not X?</a><ul>
<li><a class="reference internal" href="#buildbot" id="id8">Buildbot</a></li>
<li><a class="reference internal" href="#jenkins-hudson" id="id9">Jenkins/Hudson</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#components" id="id10">Components</a><ul>
<li><a class="reference internal" href="#planner" id="id11">Planner</a><ul>
<li><a class="reference internal" href="#planner-job-queue" id="id12">Planner -&gt; Job Queue</a></li>
</ul>
</li>
<li><a class="reference internal" href="#job-queue" id="id13">Job Queue</a><ul>
<li><a class="reference internal" href="#http-api" id="id14">HTTP API</a></li>
<li><a class="reference internal" href="#zmq-api" id="id15">ZMQ API</a></li>
<li><a class="reference internal" href="#job-queue-slave-wrangler" id="id16">Job Queue -&gt; Slave Wrangler</a></li>
<li><a class="reference internal" href="#job-queue-status" id="id17">Job Queue -&gt; Status</a></li>
</ul>
</li>
<li><a class="reference internal" href="#slave-wrangler" id="id18">Slave Wrangler</a><ul>
<li><a class="reference internal" href="#slave-wrangler-slave" id="id19">Slave Wrangler -&gt; Slave</a></li>
</ul>
</li>
<li><a class="reference internal" href="#slave" id="id20">Slave</a><ul>
<li><a class="reference internal" href="#slave-job-queue" id="id21">Slave -&gt; Job Queue</a></li>
<li><a class="reference internal" href="#slave-files" id="id22">Slave -&gt; Files</a></li>
<li><a class="reference internal" href="#slave-status" id="id23">Slave -&gt; Status</a></li>
</ul>
</li>
<li><a class="reference internal" href="#status" id="id24">Status</a><ul>
<li><a class="reference internal" href="#id1" id="id25">HTTP API</a></li>
<li><a class="reference internal" href="#id2" id="id26">ZMQ API</a></li>
<li><a class="reference internal" href="#status-slave" id="id27">Status -&gt; Slave</a></li>
<li><a class="reference internal" href="#status-event" id="id28">Status -&gt; Event</a></li>
</ul>
</li>
<li><a class="reference internal" href="#event" id="id29">Event</a><ul>
<li><a class="reference internal" href="#event-planner" id="id30">Event -&gt; Planner</a></li>
</ul>
</li>
<li><a class="reference internal" href="#files" id="id31">Files</a><ul>
<li><a class="reference internal" href="#files-slave" id="id32">Files -&gt; Slave</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#objects" id="id33">Objects</a><ul>
<li><a class="reference internal" href="#scheduler" id="id34">Scheduler</a></li>
<li><a class="reference internal" href="#job-set" id="id35">Job Set</a></li>
<li><a class="reference internal" href="#job" id="id36">Job</a></li>
</ul>
</li>
<li><a class="reference internal" href="#access-control" id="id37">Access control</a><ul>
<li><a class="reference internal" href="#buckets" id="id38">Buckets</a></li>
<li><a class="reference internal" href="#random-ideas" id="id39">random ideas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#resource-policies" id="id40">Resource policies</a></li>
<li><a class="reference internal" href="#todo" id="id41">TODO</a></li>
</ul>
</div>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#id3">Overview</a></h1>
<p>Large Wooden Rabbit is the code name for the next generation of Release
Engineering's build infrastructure.</p>
<p><a class="reference external" href="http://people.mozilla.org/~asasaki/wb2/01-webbuild2.html">http://people.mozilla.org/~asasaki/wb2/01-webbuild2.html</a></p>
<div class="section" id="goals">
<h2><a class="toc-backref" href="#id4">Goals</a></h2>
<p>LWR will:</p>
<ul class="simple">
<li>be open source</li>
<li>be made of reusable components</li>
<li>be usable outside of Mozilla</li>
<li>allow you to simply rebuild failed tasks, or hierarchies of tasks. These
rebuilt tasks can satisfy previous dependency graphs.</li>
<li>allow you to specify <a class="reference external" href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAGs</a> for job dependencies</li>
<li>be able to change scheduling at run time via a web interface or API. some
examples:<ul>
<li>enable a new branch</li>
<li>change tests running on a branch</li>
<li>clone an existing branch config and modify it to report to an alternate
location. This can be used to test out changes to the scheduling
process.</li>
</ul>
</li>
<li>operate at scale. This means:<ul>
<li>support multiple distributed clusters of slaves and 'masters'</li>
<li>support 10<sup>5</sup> slaves</li>
<li>support 10<sup>5</sup> pending jobs</li>
</ul>
</li>
<li>Allow community members or other developer hosted projects to participate
more easily<ul>
<li>allow results to be submitted to be associated with e.g.
mozilla-central changesets. For example, somebody should be able to
build a static analysis test on his own machine, and have those results
available in the same place as the official build and test results,
associated with the revision of mozilla-central he did the tests from.</li>
<li>allow external community systems to connect and get jobs from LWR. This
could be through direct connections, or a pubsub system.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="use-cases">
<h2><a class="toc-backref" href="#id5">Use cases</a></h2>
<ol class="arabic">
<li><p class="first">Ability to determine when a whole hierarchy of jobs has finished. For
example, a developer's push to try triggers opt and debug builds on <em>N</em>
platforms, and each one of those triggers tests. There can also be other
types of jobs like valgrind or code analysis that.  Currently this is
difficult in buildbot because there is a very weak correspondence
betweeen builds and tests triggered via sendchange, as well as the
asynchronous nature of buildbot scheduling.</p>
<p>This is currently a pain point with our existing buildbot setup since
there is no direct relationship between pushes, builds and tests.
retries and nightly builds add to the confusion. Tools like autoland and
buildapi have lots of complex code to try and get at all the jobs
related to one push.</p>
</li>
<li><p class="first">Ability to determine what jobs a given event <em>would</em> trigger. Kind of
like a --dry-run mode for planners. This would be used by people
working on the planners to see if a change they made results in the
expected jobs.</p>
<p>This is currently very difficult to do with our existing configs since
tests are triggered only after builds have finished, so you need to know
how to line up the build's sendchange with the test schedulers.</p>
</li>
<li><p class="first">Cancel a running or pending job.</p>
</li>
<li><p class="first">Pause a running job for inspection.
Arthur, a graphics developer, is trying to track down a test failure. He
would like to interrupt a running job so that the machine state can
be inspected while the test is being run. Arthur logs into LWR's web
interface and sees that a test job is running. He selects the job and
clicks the &quot;pause button&quot; and then asks buildduty to have a look at the
machine.</p>
<p>This is currently impossible to do.</p>
</li>
<li><p class="first">Add support for a new branch</p>
</li>
<li><p class="first">Test a new planner
Bilbo, a release engineer, is testing out a change to the
mozilla-firefox-branch.py planner that creates build and test jobs for
pushes to firefox repositories. He's already written unittest for the
planner and verified that it's worked correctly with local testing.
However, given last week's busted landing, he would like to run this
side-by-side the existing production planner before going live with
it.</p>
<p>Bilbo logs into LWR's web interface and navigates to the planners
page. He copies the entry for production version of
mozilla-firefox-branch.py. He modifies his copy to pull from his user
repository and to report to his bucket, and then clicks &quot;Save changes.&quot;</p>
<p>From that point on, all the same events which cause
mozilla-firefox-branch to run will cause Bilbo's modified planner to
run as well.</p>
<p>We try and accomplish this currently by running things in our staging
environment. The problems with this are that the staging slaves are
often tainted by previous work, there are not enough resources to go
around, and it's impractical to test all the affected builders for many
changes.</p>
</li>
<li><p class="first">Hal, a mobile developer, is trying to get a new test suite up and
running for the android builds. He would like to test his new robocop
test using the test code in his repository against last night's android
build.</p>
<p>Because Hal doesn't need all the newfangled features of LWR's planners,
he decides to kick off the tests manually. The first time Hal needs to
do this, he logs onto LWR's interface and goes to the Jobs section. He
selects 'new job' which opens an interface that allows him to specify
which script will be run, which parameters to pass it it and which
slave(s) to run the job on. When he's done, he can click on 'do it!',
which will create his new job in the <a class="reference internal" href="#job-queue">job queue</a>.</p>
<p>If this is not his first time doing this, he can go to the status
interface of LWR and find his previous test run by searching for jobs
with his username associated with them, or with the string 'robocop' in
their name. He can then select 'edit &amp; run again' which will open an
interface that allows him to edit the parameters of the test run.
Excited that he'll finally be able to get the tests passing, he updates
the revision of his test repository that the test job is using, and
clicks 'do it!'.</p>
<p>Joel is Hal's manager, and wants to see how far along Hal is to
completing his work since the deadline is next week. He also can use the
status interface of LWR to look at all of Hal's jobs and filter out all
the jobs except robocop. Happily the tests have just started passing.</p>
</li>
</ol>
</div>
<div class="section" id="anti-goals">
<h2><a class="toc-backref" href="#id6">Anti-Goals</a></h2>
<p>LWR will not:</p>
<ul class="simple">
<li>replace <a class="reference external" href="http://tbpl.mozilla.org">TBPL</a>, although it should simplify fetching of build results</li>
<li>gain you access to fortified french castles</li>
</ul>
</div>
<div class="section" id="why-not-x">
<h2><a class="toc-backref" href="#id7">Why not X?</a></h2>
<div class="section" id="buildbot">
<h3><a class="toc-backref" href="#id8">Buildbot</a></h3>
<p>Buildbot has served us well, but has a few fundamental limitations that
are very difficult to change or work around:</p>
<ul class="simple">
<li>require constant connection between build master and slave. This puts a
high load on network infrastructure which causes burnt builds/tests due
to dropped connections, and makes it hard to do maintenance on masters.
Having build slave &lt;-&gt; master(s) communication be resilient to failure or
being able to have slaves fall over to another master would be a great
improvement to system stability.</li>
<li>scheduling is opaque and difficult to change at run-time. buildbot
doesn't provide much in the way of interfaces to the schedulers.
Sometimes they log things to the master log files, most of the time
they don't. Debugging misbehaving schedulers is a bit of a black art.
Execution of one scheduler can block execution of other schedulers.
It's also difficult to alter the set of jobs that happen as part of a
build or test run at runtime. reconfigs don't cut it.</li>
<li>poor support for non-trivial hierarchies of jobs. If you have a process
with many fanout and collection points, it's very difficult to
represent this in buildbot. It's even harder to know reliably when
everything in the process is done.</li>
<li>no single source of truth for build status. We've been maintaining our
own mysql database to store build status, but it's not directly
associated with the schedulerdb. Providing a consistent view of these
databases is complicated; exports to other applications is expensive and
complex.</li>
</ul>
</div>
<div class="section" id="jenkins-hudson">
<h3><a class="toc-backref" href="#id9">Jenkins/Hudson</a></h3>
<p>Jenkins seems well suited to simple processes, but for handling a large set
of complex tasks.</p>
<p>I really don't know it well enough to evaluate though. It's written in java
though :\</p>
</div>
</div>
</div>
<div class="section" id="components">
<h1><a class="toc-backref" href="#id10">Components</a></h1>
<img alt="arch.png" src="arch.png" />
<div class="section" id="planner">
<h2><a class="toc-backref" href="#id11">Planner</a></h2>
<p>The planner is responsible for responding to events and creating new jobs.
The planner maintains a list of <a class="reference internal" href="#scheduler">Scheduler</a>s that respond to incoming
events and create new jobs to run in reponse to those events.</p>
<div class="section" id="planner-job-queue">
<h3><a class="reference internal" href="#planner">Planner</a> -&gt; <a class="reference internal" href="#job-queue">Job Queue</a></h3>
<p>The <a class="reference internal" href="#planner">planner</a> has a one-way communication with the <a class="reference internal" href="#job-queue">job queue</a>, it simply
notifies the <a class="reference internal" href="#job-queue">job queue</a> of new jobs to run.</p>
<ul class="simple">
<li>New job</li>
</ul>
</div>
</div>
<div class="section" id="job-queue">
<h2><a class="toc-backref" href="#id13">Job Queue</a></h2>
<p>The <a class="reference internal" href="#job-queue">job queue</a> is responsible for tracking new jobs, sending them for
execution to the <a class="reference internal" href="#slave-wrangler">slave wrangler</a> if required, or queuing them up for later
processing.</p>
<p>All modifications to jobs are done through this component. This includes
cancelling or pausing jobs.</p>
<p>TODO:
It's a bit weird that there's little reading done from the queue. It looks
like a scheduler will have to query <a class="reference internal" href="#status">status</a> to find old jobs/jobsets to act
on. either that or <a class="reference internal" href="#job-queue">job queue</a> will duplicate a lot of <a class="reference internal" href="#status">status</a>, which
doesn't seem like a good idea.</p>
<p>Although, these scheduling decisions are inherently racey and
asynchronous, so perhaps splitting it up is fine.</p>
<p>One of the primary uses that would involve both getting other job statuses
and modifying others is schedulers that merge pending requests. They need
to get a list of pending jobs of a certain type (TODO: figure out if this
is easy or not!), and mark the older ones are merged.</p>
<div class="section" id="http-api">
<h3><a class="toc-backref" href="#id14">HTTP API</a></h3>
<dl class="docutils">
<dt><tt class="docutils literal">POST <span class="pre">/jobqueue/v0.1/&lt;bucket&gt;/jobs</span></tt></dt>
<dd>create a new job
the id for the job is returned by this call</dd>
<dt><tt class="docutils literal">POST <span class="pre">/jobqueue/v0.1/&lt;bucket&gt;/job/&lt;jobid&gt;/trigger</span></tt></dt>
<dd>fire a trigger
TODO: Use events for this instead?</dd>
<dt><tt class="docutils literal">PUT <span class="pre">/jobqueue/v0.1/&lt;bucket&gt;/job/&lt;jobid&gt;</span></tt></dt>
<dd><p class="first">modify this job's state to cancel it, merge it, etc.</p>
<p>post-data:</p>
<p class="last">state=running, cancelled, paused, merged, etc.</p>
</dd>
</dl>
</div>
<div class="section" id="zmq-api">
<h3><a class="toc-backref" href="#id15">ZMQ API</a></h3>
<p>The <a class="reference internal" href="#job-queue">job queue</a> server(s) listen on a REP socket. Requests are made by
clients using a REQ socket with the following format:</p>
<p>TODO</p>
</div>
<div class="section" id="job-queue-slave-wrangler">
<h3><a class="reference internal" href="#job-queue">Job Queue</a> -&gt; <a class="reference internal" href="#slave-wrangler">Slave Wrangler</a></h3>
<ul class="simple">
<li>Run job A on slave X</li>
</ul>
</div>
<div class="section" id="job-queue-status">
<h3><a class="reference internal" href="#job-queue">Job Queue</a> -&gt; <a class="reference internal" href="#status">Status</a></h3>
<ul class="simple">
<li>Job A is new, running, pending, merged, etc.</li>
</ul>
</div>
</div>
<div class="section" id="slave-wrangler">
<h2><a class="toc-backref" href="#id18">Slave Wrangler</a></h2>
<p>Receives jobs from the <a class="reference internal" href="#job-queue">job queue</a> and runs them on slaves.</p>
<p>Mostly just a broker to talk to slaves.</p>
<div class="section" id="slave-wrangler-slave">
<h3><a class="reference internal" href="#slave-wrangler">Slave Wrangler</a> -&gt; <a class="reference internal" href="#slave">Slave</a></h3>
<ul class="simple">
<li>Run job A</li>
</ul>
</div>
</div>
<div class="section" id="slave">
<h2><a class="toc-backref" href="#id20">Slave</a></h2>
<p>Slaves do work!</p>
<div class="section" id="slave-job-queue">
<h3><a class="reference internal" href="#slave">Slave</a> -&gt; <a class="reference internal" href="#job-queue">Job Queue</a></h3>
<ul class="simple">
<li>Create new job</li>
<li>Send trigger (TODO: should this go via events? - that lets regular
subscriptions to event types work for the jobset scheduler)</li>
<li>Delete jobs (e.g. a scheduler job could cancel other pending work)</li>
<li>Merge jobs (e.g. a scheduler job could merge pending work together)</li>
</ul>
</div>
<div class="section" id="slave-files">
<h3><a class="reference internal" href="#slave">Slave</a> -&gt; <a class="reference internal" href="#files">Files</a></h3>
<ul class="simple">
<li>Upload files and logs, store urls</li>
<li>See also <a class="reference internal" href="#files-slave">Files -&gt; Slave</a></li>
</ul>
</div>
<div class="section" id="slave-status">
<h3><a class="reference internal" href="#slave">Slave</a> -&gt; <a class="reference internal" href="#status">Status</a></h3>
<p>Notification of job status: started, finished, including meta data like:</p>
<ul class="simple">
<li>build started/finished</li>
<li>start/stop time</li>
<li>per-step start/stop time</li>
<li>results (success, failure, etc.)</li>
<li>rich results (??? e.g. multi l10n repacks)</li>
<li>urls to logs, files</li>
<li>See also <a class="reference internal" href="#status-slave">Status -&gt; Slave</a></li>
</ul>
</div>
</div>
<div class="section" id="status">
<h2><a class="toc-backref" href="#id24">Status</a></h2>
<p>Get and retrieve status on individual jobs and job sets.</p>
<div class="section" id="id1">
<h3><a class="toc-backref" href="#id25">HTTP API</a></h3>
<dl class="docutils">
<dt><tt class="docutils literal">GET <span class="pre">/status/v0.1/&lt;bucket&gt;/jobs/&lt;jobid&gt;</span></tt></dt>
<dd>get status about job $jobid</dd>
<dt><tt class="docutils literal">GET <span class="pre">/status/v0.1/&lt;bucket&gt;/jobsets/&lt;jobsetid&gt;</span></tt></dt>
<dd>get status about $jobsetid</dd>
<dt><tt class="docutils literal">GET <span class="pre">/status/v0.1/&lt;bucket&gt;/bytags/&lt;tags&gt;</span></tt></dt>
<dd>get status about jobs associated with $tags</dd>
<dt><tt class="docutils literal">POST <span class="pre">/status/v0.1/&lt;bucket&gt;/jobs</span></tt></dt>
<dd>TODO: is this required? this doesn't actually cause a new job to get run
create new job</dd>
<dt><tt class="docutils literal">POST <span class="pre">/status/v0.1/&lt;bucket&gt;/jobsets</span></tt></dt>
<dd>TODO: is this required? this doesn't actually cause a new jobset to exist
create new jobset</dd>
<dt><tt class="docutils literal">PUT <span class="pre">/status/v0.1/&lt;bucket&gt;/jobs/&lt;jobid&gt;</span></tt></dt>
<dd>update job</dd>
<dt><tt class="docutils literal">PUT <span class="pre">/status/v0.1/&lt;bucket&gt;/jobsets/&lt;jobsetid&gt;</span></tt></dt>
<dd>update job set</dd>
</dl>
<p>Except for searching for things by tag, this looks an awful lot like S3....</p>
</div>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id26">ZMQ API</a></h3>
<p>The <a class="reference internal" href="#status">Status</a> server(s) listen on a REP socket. Requests are made by clients
using a REQ socket with the following format:</p>
<ul>
<li><dl class="first docutils">
<dt>Frame 0</dt>
<dd><dl class="first last docutils">
<dt><tt class="docutils literal">version</tt></dt>
<dd><p class="first last">status protocol version (0.1)</p>
</dd>
<dt><tt class="docutils literal">auth</tt></dt>
<dd><p class="first last">authentication information</p>
</dd>
<dt><tt class="docutils literal">bucket</tt></dt>
<dd><p class="first last">which bucket we're talking to</p>
</dd>
<dt><tt class="docutils literal">method</tt></dt>
<dd><p class="first last"><tt class="docutils literal">getjob</tt>, <tt class="docutils literal">getjobset</tt>, <tt class="docutils literal">newjob</tt>, <tt class="docutils literal">newjobset</tt>, <tt class="docutils literal">updatejob</tt>,
<tt class="docutils literal">updatejobset</tt></p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Frame 1</dt>
<dd><p class="first last"><tt class="docutils literal">job</tt> or <tt class="docutils literal">jobset</tt> data</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="status-slave">
<h3><a class="reference internal" href="#status">Status</a> -&gt; <a class="reference internal" href="#slave">Slave</a></h3>
<ul class="simple">
<li>fetch status of old jobs (e.g. a scheduler job might want to know state of other jobs)</li>
</ul>
</div>
<div class="section" id="status-event">
<h3><a class="reference internal" href="#status">Status</a> -&gt; <a class="reference internal" href="#event">Event</a></h3>
<ul class="simple">
<li>job finished</li>
<li>job added</li>
</ul>
</div>
</div>
<div class="section" id="event">
<h2><a class="toc-backref" href="#id29">Event</a></h2>
<p>Events are used by a few things in LWR:
* notifications of external things that require action, e.g.</p>
<blockquote>
<ul class="simple">
<li>hg pushes</li>
<li>request for custom build</li>
</ul>
</blockquote>
<ul class="simple">
<li>internally generated events<ul>
<li>build finished. this in turn can trigger another scheduler to run more
builds / tests</li>
<li>build trigger. e.g in our existing build process we run 'sendchange'
after uploading so that tests can get started before things like 'make
check' are run.</li>
</ul>
</li>
<li>most events are published for external consumers via http or rmq<ul>
<li>event publishing controlled by bucket policy?</li>
</ul>
</li>
</ul>
<p>Events are specified as a tuple <tt class="docutils literal">(bucket.name, data)</tt>, eg.
<tt class="docutils literal"><span class="pre">('releng.hg.mozilla-central',</span> {'revision': <span class="pre">'abcdef123456'})</span></tt></p>
<div class="section" id="event-planner">
<h3><a class="reference internal" href="#event">Event</a> -&gt; <a class="reference internal" href="#planner">Planner</a></h3>
<ul class="simple">
<li>new pushes to hg / git / cvs / etc.</li>
<li>triggers</li>
<li>builds starting / builds stopping</li>
</ul>
</div>
</div>
<div class="section" id="files">
<h2><a class="toc-backref" href="#id31">Files</a></h2>
<p>Files and logs go here.</p>
<p>The APIs for this should be pretty simple. You need to be able to upload a file and get back a URL. The existing scp / post_upload.py would suffice.</p>
<div class="section" id="files-slave">
<h3><a class="reference internal" href="#files">Files</a> -&gt; <a class="reference internal" href="#slave">Slave</a></h3>
<ul class="simple">
<li>Download files</li>
</ul>
</div>
</div>
</div>
<div class="section" id="objects">
<h1><a class="toc-backref" href="#id33">Objects</a></h1>
<div class="section" id="scheduler">
<h2><a class="toc-backref" href="#id34">Scheduler</a></h2>
<p>A scheduler is basically a job template with a list of event subscriptions.
The job template will be instantiated when a matching event is received by
the planner. The event will be attached to the job and then sent to the
<a class="reference internal" href="#job-queue">job queue</a>.</p>
<p>Schedulers are managed and triggered by the <a class="reference internal" href="#planner">planner</a>.</p>
<p>A scheduler can be specified thought of as a tuple of
(<tt class="docutils literal">owner</tt>, <tt class="docutils literal">bucket</tt>, <tt class="docutils literal">event_type</tt>, <tt class="docutils literal">job_template</tt>, <tt class="docutils literal">data</tt>).</p>
<p><tt class="docutils literal">event_type</tt> doesn't have to be in <tt class="docutils literal">owner</tt>'s bucket, as long as
<tt class="docutils literal">owner</tt> has read access to <tt class="docutils literal">event_type</tt>'s bucket.</p>
<p><tt class="docutils literal">event_type</tt> is split on the
period (<tt class="docutils literal">.</tt>), and the first element is treated as the bucket. Everything
after that is arbitrary.</p>
<p>Some examples:</p>
<ul class="simple">
<li>A &quot;jobset&quot; scheduler subscribes to &quot;&lt;bucket&gt;.build.finished&quot;, &quot;&lt;bucket&gt;.build.trigger&quot;, &quot;&lt;bucket&gt;.jobsets.new&quot; events
and creates a job that determines if any new jobs in a jobset are
runnable.</li>
<li>A &quot;mozilla&quot; scheduler subscribes to hg push events and creates a full
hierarchy of builds and tests (a <a class="reference internal" href="#job-set">job set</a>) with proper dependencies
between them.</li>
</ul>
</div>
<div class="section" id="job-set">
<h2><a class="toc-backref" href="#id35">Job Set</a></h2>
<p>A job set is a <a class="reference external" href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a> that describes a hierarchy of jobs
to run and how they're related. An example would be the set of builds
created for an hg push, and the tests for that build. The tests depend on
the builds to succeed. By creating everything under a single jobset you can
know when everything is completed or not, and have a place to look up all
the results associated with a single push.</p>
<p>Another example would be our release automation. We have a fairly complex
set of dependencies between tagging / builds / repacks / updates (en-US
builds depend on en-US tagging, repacks depend on locale tagging and en-US
builds, updates depend on builds, partner repacks depend on repacks, virus
scan depends on everything, ...)</p>
<p>Sample format:</p>
<pre class="literal-block">
A -&gt; B -&gt; C
     B -&gt; D
          D -[trigger t1]-&gt; F
     B -[onfailure]-&gt; E
</pre>
<p>Where A,B,C,D,E are job ids. A is run first.
If A succeeds, then B is run.
If B succeeds, then C and D are run.
If B fails, then E is run.
If D generates trigger t1, then F is run</p>
<p>To submit a job set, each job in the set should be created first with
state=waiting, and then the jobset can be created referencing all the job
ids. Once the jobset is submitted the jobset scheduler will run and mark
any jobs in the jobset as runnable.</p>
</div>
<div class="section" id="job">
<h2><a class="toc-backref" href="#id36">Job</a></h2>
<p>A job is an object that has the following fields:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal">id</tt></dt>
<dd><p class="first last">a unique identifier for the job</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal">command</tt></dt>
<dd><p class="first last">the command to run</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal">tags</tt></dt>
<dd><p class="first last">list of strings to tag the jobs with. some of these may be restricted
due to policy</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal">starttime/stoptime</tt></p>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal">state</tt></dt>
<dd><p class="first">One of:</p>
<dl class="last docutils">
<dt><tt class="docutils literal">pending</tt></dt>
<dd><p class="first last">this job is waiting for something else to complete before it can run</p>
</dd>
<dt><tt class="docutils literal">runnable</tt></dt>
<dd><p class="first last">this job can be run</p>
</dd>
<dt><tt class="docutils literal">running</tt></dt>
<dd><p class="first last">this job is running</p>
</dd>
<dt><tt class="docutils literal">finished</tt></dt>
<dd><p class="first last">this job is done</p>
</dd>
<dt><tt class="docutils literal">paused</tt></dt>
<dd><p class="first last">this job has been paused by a user</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal">status</tt></dt>
<dd><p class="first last">a code indicating whether the job was successful, failed, etc.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal">required_slave_tags</tt></dt>
<dd><p class="first last">what type of slave this job needs</p>
</dd>
</dl>
</li>
<li><p class="first">MOAR!</p>
</li>
</ul>
</div>
<p>* MOAR!</p>
</div>
<div class="section" id="access-control">
<h1><a class="toc-backref" href="#id37">Access control</a></h1>
<p>There are at least two options under consideration for managing access
control. We will attempt to outline them here so that a decision can be
reached.</p>
<p>The goals for access control are:</p>
<ol class="arabic simple">
<li>allow community projects to submit results without risk of polluting
other projects' data</li>
<li>make it possible to identify the canonical builds and test results for
any project</li>
<li>identify the 'owner' for jobs, planners, and files for resource
allocation</li>
<li>make it possible to have jobs and results that are non-public (e.g.
fuzzing, work for security bugs)</li>
<li>allow users to create their own planners, and to manage their own jobs.</li>
<li>make it possible to submit auxilliary information to existing projects
(e.g. tier-2 builds, static analysis of mozilla-central)</li>
</ol>
<div class="section" id="buckets">
<h2><a class="toc-backref" href="#id38">Buckets</a></h2>
<p>Every planner, job, status object, file has another piece of metadata
attached which is called its bucket.</p>
<p>There also exist users and groups in the system.</p>
<p>Buckets have a list of users and groups with read/write permissions.</p>
<p>Planners create jobs in their own bucket. Jobs report results to the same
bucket.</p>
<p>How does it accomplish the goals?</p>
<ol class="arabic simple">
<li>since results for jobs are contained to their bucket, there is no risk
of pollution. each project (e.g. 'firefox', 'jetpack', 'thunderbird',
'seamonkey') could have its own bucket.</li>
<li>owners of the jobs can tag items in their bucket with 'official' if it's
desirable for them to do that. presumably only builds/tests in the
'firefox' are canonical. extra tags could be added to distinguish dep
builds from nightlies from release, etc.</li>
<li>resource allocation could be done per bucket rather than for individual
users or groups.</li>
<li>non-public jobs would go into buckets with limited read/write access</li>
<li>a user with write permissions to a bucket is able to create/modify the
set of planners. the same technique could be used to allow running new
jobs, cancelling running ones, etc.</li>
<li>leave it to the status displays (e.g. tbpl) to select which buckets and
results they want to look at</li>
</ol>
<p>Pros:</p>
<ul class="simple">
<li>simple</li>
</ul>
<p>Cons:</p>
<ul class="simple">
<li>puts more burden on status displays to look in all buckets they're
interested in. this could be a good thing, it enforces goal 1.</li>
</ul>
</div>
<div class="section" id="random-ideas">
<h2><a class="toc-backref" href="#id39">random ideas</a></h2>
<p><em>This section isn't finished yet - just some random thoughts here for now</em></p>
<p>What about buckets? S3 gives coarse grain access control with
buckets...that's nice!  It's also gives you a separate namespace per
bucket, which is also nice!</p>
<p>possible buckets:</p>
<ul class="simple">
<li>mozilla-central</li>
<li>mozilla-inbound</li>
<li>nanojit</li>
<li>thunderbird/mozilla-central</li>
<li>mozilla-release</li>
<li>seamonkey/mozilla-central</li>
<li>emscripten</li>
<li>tenfourfox/mozilla-central</li>
<li>fuzzing</li>
<li>mozilla_releng</li>
</ul>
<p>however, access control at a per bucket level would make it hard for
community projects to be involved, unless they were given their own bucket.
in the case of several projects based around a single repository, but
spread across many buckets, status reporting tools (like tbpl) would need
to know to look in different buckets for results. The <a class="reference internal" href="#status">status</a> API could
include querying by bucket as well as by tag, or buckets could be an
implicit tag.</p>
<p>Can we have hierarchical name spaces?</p>
<ul class="simple">
<li>mozilla-central.firefox</li>
<li>mozilla-central.tenfourfox</li>
<li>mozilla-central.thunderbird</li>
</ul>
<p>instead, can we have ACLs on certain tags?</p>
<dl class="docutils">
<dt>e.g.:</dt>
<dd><p class="first">&quot;mozilla-central&quot;: requires auth releng</p>
<p>&quot;mozilla-central&quot;, &quot;static-analysis&quot;: requires auth foo</p>
<p>&quot;mozilla-central&quot;, &quot;comm-central&quot;, &quot;seamonkey&quot;: requires auth bar</p>
<p class="last">&quot;mozilla-central&quot;, &quot;release&quot;: requires auth releng</p>
</dd>
</dl>
<p>the more I think about this, the more I like buckets. trying to resolve
ACLs on sets of tags seems complicated.</p>
<p>having a single flat bucket namespace is clean and simple.</p>
</div>
</div>
<div class="section" id="resource-policies">
<h1><a class="toc-backref" href="#id40">Resource policies</a></h1>
<p>We need to enforce certain kind of resource policies or prioritizations,
e.g.:</p>
<ul class="simple">
<li>mozilla-central builds are more important than elm</li>
<li>fuzzing jobs should only happen at idle time, and make sure that it
doesn't consume all available slaves</li>
<li>mozilla-central should be guaranteed X% of the resources</li>
<li>guarantee Y% to developer / community jobs.</li>
</ul>
</div>
<div class="section" id="todo">
<h1><a class="toc-backref" href="#id41">TODO</a></h1>
<ul>
<li><p class="first">Policy control</p>
<ul class="simple">
<li>who can run what type of jobs, and how often?</li>
<li>control over tags</li>
<li>resource allocation</li>
</ul>
</li>
<li><p class="first">Split up <a class="reference internal" href="#job-queue">job queue</a> into pieces that queue jobs, mark as runnable, etc.?</p>
<ul class="simple">
<li>marking jobs as runnable is handled by a scheduler that manages job
sets.</li>
</ul>
</li>
<li><p class="first">Integration with other tools, like tree status - when tree is closed,
stop new jobs from getting scheduled. When infra fails, automatically
close tree.</p>
</li>
<li><p class="first">Data integrity - how do we ensure that commands and build artifacts are
transferred throughout the system without tampering</p>
</li>
<li><p class="first">Managing secrets. Lots of times we have slaves deal with sensitive
information. How can we get secrets on and off of the slaves securely?</p>
</li>
<li><p class="first">Log streaming. It would be nice to be stream log files to developers. I
think zmq would be great for this.</p>
</li>
<li><p class="first">MOAR buckets!</p>
<ul class="simple">
<li>planner could list schedulers by bucket. auth'ed users could change the
scheduling for their bucket</li>
<li>events are per bucket</li>
<li>files are per bucket</li>
</ul>
</li>
<li><p class="first">specify ZMQ message encoding</p>
</li>
<li><p class="first">reaper
ttls</p>
</li>
<li><p class="first">chaos monkey</p>
</li>
<li><p class="first">timers (for generating events)</p>
</li>
<li><p class="first">is merging in the scheduler the right thing to do?
a scheduler has the context and knowledge for what types of jobs are
mergable and not, and how many could be merged at once</p>
<p>buildbot currently merges at the time when jobs are assigned to slaves</p>
</li>
<li><p class="first">performance monitoring, correspond to build 'steps'</p>
<blockquote>
<ul class="simple">
<li>mozharness could dump out current step to well defined location
(file)</li>
</ul>
</blockquote>
</li>
<li><p class="first">breakpoints for jobs? (supported by extra data sent in event, passed
along to mozharness script?) job can pause itself? pause-after-run.</p>
</li>
<li><p class="first">integrate vnc / console?</p>
</li>
<li><p class="first">jobs that span slaves</p>
</li>
<li><p class="first">&quot;reserving&quot; slaves between jobs</p>
</li>
<li><p class="first">where does job prioritization happen? can it be a separate script?</p>
</li>
<li><p class="first">Figure out ACLs / buckets / etc.</p>
</li>
<li><p class="first">Configuration-as-code has the advantage of being able to put the
configuration in source control.</p>
</li>
</ul>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2012-03-27 15:20 UTC.

</div>
</body>
</html>
